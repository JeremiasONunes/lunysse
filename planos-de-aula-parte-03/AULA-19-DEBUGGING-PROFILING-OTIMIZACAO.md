# PLANO DE TRABALHO DOCENTE

## MODELO PEDAG√ìGICO SENAC

**Curso:** Desenvolvedor Full Stack  
**Carga Hor√°ria Total:** 108h  
**Carga Hor√°ria da UC:** 108h  
**Docente:** Jeremias O Nunes

---

# PLANO DE AULA ‚Äì Debugging, Profiling e Otimiza√ß√£o Avan√ßada

üìå **Disciplina:** Desenvolvimento Front-end Avan√ßado  
üë®üè´ **Mentor(a):** Jeremias O Nunes  
üìÜ **Data:** Aula 19 - Parte 3  
‚è∞ **Dura√ß√£o:** 4 horas

---

## üìñ Planejamento

### üìå Conte√∫do Formativo

‚Ä¢ Laborat√≥rio avan√ßado de Chrome DevTools para debugging profissional  
‚Ä¢ Workshop intensivo de memory profiling e detec√ß√£o de vazamentos de mem√≥ria  
‚Ä¢ Implementa√ß√£o de sistema de logging e monitoramento em tempo real  
‚Ä¢ Cria√ß√£o de testes de performance automatizados com m√©tricas personalizadas  
‚Ä¢ Otimiza√ß√£o avan√ßada de bundle e implementa√ß√£o de code splitting inteligente  
‚Ä¢ Auditoria completa de qualidade do c√≥digo com ferramentas profissionais  
‚Ä¢ Implementa√ß√£o de Error Boundary e tratamento robusto de erros  
‚Ä¢ Desenvolvimento de dashboard de monitoramento de performance em produ√ß√£o

### üéØ Objetivo Geral

Dominar t√©cnicas avan√ßadas de debugging e otimiza√ß√£o para garantir qualidade e performance profissional da aplica√ß√£o, implementando metodologias sistem√°ticas de identifica√ß√£o, diagn√≥stico e corre√ß√£o de problemas que assegurem a confiabilidade do Sistema Lunysse em ambiente de produ√ß√£o.

### üí° Habilidades e Compet√™ncias

‚úÖ **Debugging Avan√ßado:** Dominar ferramentas profissionais de debugging e an√°lise de c√≥digo  
‚úÖ **Memory Management:** Identificar e corrigir vazamentos de mem√≥ria e otimizar uso de recursos  
‚úÖ **Performance Profiling:** Analisar e otimizar performance usando m√©tricas detalhadas  
‚úÖ **Error Handling:** Implementar tratamento robusto de erros e recovery strategies  
‚úÖ **Code Quality:** Estabelecer padr√µes de qualidade e processos de auditoria  
‚úÖ **Monitoring:** Criar sistemas de monitoramento e alertas para produ√ß√£o  
‚úÖ **Bundle Optimization:** Otimizar builds e implementar estrat√©gias de carregamento

### üìå Materiais Necess√°rios

üìå Sistema Lunysse com todas as funcionalidades implementadas  
üìå Chrome DevTools e Firefox Developer Tools  
üìå Ferramentas de profiling (Lighthouse, WebPageTest, Bundle Analyzer)  
üìå Sistemas de monitoramento (Sentry, LogRocket, New Relic)  
üìå Ferramentas de an√°lise de c√≥digo (ESLint, SonarQube, CodeClimate)  
üìå Ambiente de produ√ß√£o simulado para testes de carga  
üìå Dispositivos variados para teste de performance cross-platform

---

## üéì Estrat√©gias de Ensino e Aprendizagem

### Introdu√ß√£o e Contextualiza√ß√£o (45 min)

**Reflex√£o inicial:** "Por que debugging e otimiza√ß√£o s√£o cr√≠ticos em aplica√ß√µes de sa√∫de onde vidas podem depender da confiabilidade do sistema?"

Discuss√£o aprofundada sobre casos reais onde falhas de software em sistemas m√©dicos causaram problemas graves. An√°lise de incidentes como o bug do Therac-25 e problemas em sistemas hospitalares modernos, enfatizando a import√¢ncia de debugging rigoroso e monitoramento cont√≠nuo.

**Contextualiza√ß√£o profissional:** Apresenta√ß√£o de metodologias utilizadas por empresas l√≠deres em healthtech (Epic, Cerner, Allscripts) para garantir qualidade e confiabilidade. Demonstra√ß√£o de como grandes sistemas m√©dicos implementam monitoring, alertas e recovery strategies.

**An√°lise de cen√°rio:** Simula√ß√£o de problemas reais que podem ocorrer no Sistema Lunysse em produ√ß√£o, incluindo vazamentos de mem√≥ria durante uso intensivo, problemas de performance com grandes volumes de dados, e falhas de rede durante opera√ß√µes cr√≠ticas.

---

### T√≥pico 1: Chrome DevTools Avan√ßado e Debugging Profissional (85 min)

#### üìå Demonstra√ß√£o Pr√°tica:
O mentor demonstrar√° uso profissional completo do Chrome DevTools:
- **Sources Panel:** Debugging avan√ßado com breakpoints condicionais e logpoints
- **Performance Panel:** Profiling detalhado de CPU, rendering e network
- **Memory Panel:** An√°lise de heap snapshots e detec√ß√£o de memory leaks
- **Network Panel:** An√°lise de requisi√ß√µes, timing e otimiza√ß√£o de recursos
- **Application Panel:** Debugging de Service Workers, Storage e Cache

```javascript
// Exemplo demonstrado pelo mentor
class AdvancedDebugger {
  constructor() {
    this.debugMode = process.env.NODE_ENV === 'development';
    this.performanceMarks = new Map();
    this.errorLog = [];
    this.setupAdvancedDebugging();
  }

  // Sistema avan√ßado de logging
  log(level, message, context = {}) {
    const logEntry = {
      timestamp: new Date().toISOString(),
      level,
      message,
      context,
      stack: new Error().stack,
      userAgent: navigator.userAgent,
      url: window.location.href
    };

    // Console logging com styling
    const styles = {
      error: 'color: #ff4444; font-weight: bold;',
      warn: 'color: #ffaa00; font-weight: bold;',
      info: 'color: #4444ff;',
      debug: 'color: #888888;'
    };

    console.log(`%c[${level.toUpperCase()}] ${message}`, styles[level], context);

    // Armazenar para an√°lise posterior
    this.errorLog.push(logEntry);

    // Enviar para servi√ßo de monitoramento em produ√ß√£o
    if (!this.debugMode && level === 'error') {
      this.sendToMonitoringService(logEntry);
    }
  }

  // Performance marking avan√ßado
  startPerformanceMark(name) {
    const markName = `${name}-start`;
    performance.mark(markName);
    this.performanceMarks.set(name, { start: performance.now() });
    
    if (this.debugMode) {
      console.time(name);
    }
  }

  endPerformanceMark(name) {
    const markData = this.performanceMarks.get(name);
    if (markData) {
      const endTime = performance.now();
      const duration = endTime - markData.start;
      
      performance.mark(`${name}-end`);
      performance.measure(name, `${name}-start`, `${name}-end`);
      
      this.performanceMarks.set(name, { ...markData, end: endTime, duration });
      
      if (this.debugMode) {
        console.timeEnd(name);
        console.log(`%c‚è±Ô∏è ${name}: ${duration.toFixed(2)}ms`, 'color: #00aa00;');
      }

      // Alert para opera√ß√µes muito lentas
      if (duration > 1000) {
        this.log('warn', `Slow operation detected: ${name}`, { duration });
      }
    }
  }

  // Memory usage monitoring
  monitorMemoryUsage() {
    if ('memory' in performance) {
      const memory = performance.memory;
      const memoryInfo = {
        usedJSHeapSize: memory.usedJSHeapSize,
        totalJSHeapSize: memory.totalJSHeapSize,
        jsHeapSizeLimit: memory.jsHeapSizeLimit,
        timestamp: Date.now()
      };

      // Alert para uso excessivo de mem√≥ria
      const memoryUsagePercent = (memory.usedJSHeapSize / memory.jsHeapSizeLimit) * 100;
      if (memoryUsagePercent > 80) {
        this.log('warn', 'High memory usage detected', memoryInfo);
      }

      return memoryInfo;
    }
  }

  // Debugging de eventos e state changes
  debugStateChange(component, oldState, newState) {
    if (this.debugMode) {
      console.group(`üîÑ State Change: ${component}`);
      console.log('Old State:', oldState);
      console.log('New State:', newState);
      console.log('Diff:', this.getStateDiff(oldState, newState));
      console.groupEnd();
    }
  }

  getStateDiff(oldState, newState) {
    const diff = {};
    const allKeys = new Set([...Object.keys(oldState), ...Object.keys(newState)]);
    
    allKeys.forEach(key => {
      if (oldState[key] !== newState[key]) {
        diff[key] = { old: oldState[key], new: newState[key] };
      }
    });
    
    return diff;
  }

  // Network request debugging
  debugNetworkRequest(url, options, response) {
    if (this.debugMode) {
      console.group(`üåê Network Request: ${url}`);
      console.log('Options:', options);
      console.log('Response:', response);
      console.log('Timing:', response.timing);
      console.groupEnd();
    }
  }
}
```

#### üìå Atividade Pr√°tica 1:
üéØ **Objetivo:** Implementar sistema completo de debugging avan√ßado no Sistema Lunysse  
üìù **Tarefa:**
- Implementar AdvancedDebugger class com logging estruturado
- Configurar breakpoints condicionais para cen√°rios espec√≠ficos
- Criar sistema de performance marking para opera√ß√µes cr√≠ticas
- Implementar monitoring de memory usage em tempo real
- Desenvolver debugging de state changes em componentes React
- Criar sistema de debugging para network requests
- Implementar error boundaries com logging detalhado
- Configurar source maps para debugging em produ√ß√£o
- Criar dashboard de debugging para desenvolvimento
- Testar debugging em diferentes cen√°rios de erro

---

### T√≥pico 2: Memory Profiling e Detec√ß√£o de Vazamentos (75 min)

#### üìå Demonstra√ß√£o Pr√°tica:
T√©cnicas avan√ßadas de an√°lise de mem√≥ria:
- **Heap Snapshots:** An√°lise detalhada de objetos em mem√≥ria
- **Memory Leaks:** Identifica√ß√£o e corre√ß√£o de vazamentos
- **Garbage Collection:** Otimiza√ß√£o de limpeza de mem√≥ria
- **Object Lifecycle:** Rastreamento de ciclo de vida de objetos
- **Memory Profiling:** An√°lise de padr√µes de uso de mem√≥ria

```javascript
// Exemplo demonstrado pelo mentor
class MemoryProfiler {
  constructor() {
    this.objectRegistry = new WeakMap();
    this.memorySnapshots = [];
    this.leakDetectors = new Set();
    this.setupMemoryProfiling();
  }

  // Sistema de detec√ß√£o de memory leaks
  setupMemoryProfiling() {
    // Monitoramento peri√≥dico de mem√≥ria
    setInterval(() => {
      this.takeMemorySnapshot();
      this.detectMemoryLeaks();
    }, 30000); // A cada 30 segundos

    // Detector de objetos n√£o coletados
    this.setupObjectLifecycleTracking();
  }

  takeMemorySnapshot() {
    if ('memory' in performance) {
      const snapshot = {
        timestamp: Date.now(),
        usedJSHeapSize: performance.memory.usedJSHeapSize,
        totalJSHeapSize: performance.memory.totalJSHeapSize,
        jsHeapSizeLimit: performance.memory.jsHeapSizeLimit
      };

      this.memorySnapshots.push(snapshot);

      // Manter apenas os √∫ltimos 20 snapshots
      if (this.memorySnapshots.length > 20) {
        this.memorySnapshots.shift();
      }

      return snapshot;
    }
  }

  detectMemoryLeaks() {
    if (this.memorySnapshots.length < 5) return;

    const recent = this.memorySnapshots.slice(-5);
    const trend = this.calculateMemoryTrend(recent);

    // Detectar crescimento consistente de mem√≥ria
    if (trend.isIncreasing && trend.averageIncrease > 1024 * 1024) { // 1MB
      console.warn('üö® Potential memory leak detected', {
        trend,
        snapshots: recent
      });

      // Trigger garbage collection se dispon√≠vel
      if (window.gc) {
        window.gc();
      }
    }
  }

  calculateMemoryTrend(snapshots) {
    let increases = 0;
    let totalIncrease = 0;

    for (let i = 1; i < snapshots.length; i++) {
      const diff = snapshots[i].usedJSHeapSize - snapshots[i-1].usedJSHeapSize;
      if (diff > 0) {
        increases++;
        totalIncrease += diff;
      }
    }

    return {
      isIncreasing: increases >= snapshots.length * 0.8,
      averageIncrease: totalIncrease / snapshots.length,
      totalIncrease
    };
  }

  // Rastreamento de ciclo de vida de objetos
  setupObjectLifecycleTracking() {
    const originalAddEventListener = EventTarget.prototype.addEventListener;
    const originalRemoveEventListener = EventTarget.prototype.removeEventListener;

    // Rastrear event listeners n√£o removidos
    EventTarget.prototype.addEventListener = function(type, listener, options) {
      if (!this._eventListeners) {
        this._eventListeners = new Map();
      }
      
      if (!this._eventListeners.has(type)) {
        this._eventListeners.set(type, new Set());
      }
      
      this._eventListeners.get(type).add(listener);
      return originalAddEventListener.call(this, type, listener, options);
    };

    EventTarget.prototype.removeEventListener = function(type, listener, options) {
      if (this._eventListeners && this._eventListeners.has(type)) {
        this._eventListeners.get(type).delete(listener);
      }
      return originalRemoveEventListener.call(this, type, listener, options);
    };
  }

  // An√°lise de objetos grandes em mem√≥ria
  analyzeLargeObjects() {
    const largeObjects = [];
    
    // Simular an√°lise de objetos (em produ√ß√£o usaria heap snapshot)
    const checkObject = (obj, path = 'root') => {
      if (typeof obj !== 'object' || obj === null) return;
      
      const size = this.estimateObjectSize(obj);
      if (size > 1024 * 100) { // Objetos maiores que 100KB
        largeObjects.push({ path, size, obj });
      }
      
      // Recursivamente verificar propriedades
      Object.keys(obj).forEach(key => {
        if (typeof obj[key] === 'object' && obj[key] !== null) {
          checkObject(obj[key], `${path}.${key}`);
        }
      });
    };

    // Analisar objetos globais conhecidos
    if (window.appState) checkObject(window.appState, 'appState');
    if (window.cache) checkObject(window.cache, 'cache');

    return largeObjects;
  }

  estimateObjectSize(obj) {
    let size = 0;
    const seen = new WeakSet();

    const calculate = (item) => {
      if (seen.has(item)) return;
      seen.add(item);

      switch (typeof item) {
        case 'string':
          size += item.length * 2; // UTF-16
          break;
        case 'number':
          size += 8;
          break;
        case 'boolean':
          size += 4;
          break;
        case 'object':
          if (item !== null) {
            Object.keys(item).forEach(key => {
              size += key.length * 2;
              calculate(item[key]);
            });
          }
          break;
      }
    };

    calculate(obj);
    return size;
  }

  // Cleanup de recursos
  cleanup() {
    // Limpar event listeners
    document.querySelectorAll('*').forEach(element => {
      if (element._eventListeners) {
        element._eventListeners.forEach((listeners, type) => {
          listeners.forEach(listener => {
            element.removeEventListener(type, listener);
          });
        });
      }
    });

    // Limpar timers
    const highestTimeoutId = setTimeout(() => {}, 0);
    for (let i = 0; i < highestTimeoutId; i++) {
      clearTimeout(i);
    }

    const highestIntervalId = setInterval(() => {}, 0);
    clearInterval(highestIntervalId);
    for (let i = 0; i < highestIntervalId; i++) {
      clearInterval(i);
    }
  }
}
```

#### üìå Atividade Pr√°tica 2:
üéØ **Objetivo:** Implementar sistema completo de memory profiling no Sistema Lunysse  
üìù **Tarefa:**
- Implementar MemoryProfiler class com detec√ß√£o autom√°tica de leaks
- Criar sistema de monitoramento cont√≠nuo de uso de mem√≥ria
- Desenvolver rastreamento de ciclo de vida de objetos cr√≠ticos
- Implementar an√°lise de objetos grandes em mem√≥ria
- Criar sistema de cleanup autom√°tico de recursos
- Desenvolver alertas para uso excessivo de mem√≥ria
- Implementar profiling de componentes React espec√≠ficos
- Criar relat√≥rios detalhados de uso de mem√≥ria
- Testar com cen√°rios de uso intensivo
- Otimizar componentes identificados como problem√°ticos

---

### Pausa (15 min)

---

### T√≥pico 3: Sistema de Logging e Monitoramento em Tempo Real (80 min)

#### üìå Demonstra√ß√£o Pr√°tica:
Implementa√ß√£o de sistema completo de logging e monitoramento:
- **Structured Logging:** Logs estruturados para an√°lise automatizada
- **Real-time Monitoring:** Monitoramento em tempo real de m√©tricas
- **Error Tracking:** Rastreamento e categoriza√ß√£o de erros
- **Performance Metrics:** Coleta de m√©tricas de performance
- **User Analytics:** An√°lise de comportamento do usu√°rio

```javascript
// Exemplo demonstrado pelo mentor
class MonitoringSystem {
  constructor(config = {}) {
    this.config = {
      endpoint: config.endpoint || '/api/monitoring',
      batchSize: config.batchSize || 10,
      flushInterval: config.flushInterval || 5000,
      enableUserTracking: config.enableUserTracking || true,
      enablePerformanceTracking: config.enablePerformanceTracking || true,
      ...config
    };

    this.logBuffer = [];
    this.metrics = new Map();
    this.userSession = this.initializeUserSession();
    this.setupMonitoring();
  }

  initializeUserSession() {
    return {
      sessionId: this.generateSessionId(),
      userId: this.getCurrentUserId(),
      startTime: Date.now(),
      userAgent: navigator.userAgent,
      viewport: {
        width: window.innerWidth,
        height: window.innerHeight
      },
      connection: this.getConnectionInfo()
    };
  }

  // Sistema de logging estruturado
  log(level, event, data = {}) {
    const logEntry = {
      timestamp: Date.now(),
      level,
      event,
      data,
      session: this.userSession.sessionId,
      userId: this.userSession.userId,
      url: window.location.href,
      referrer: document.referrer,
      stack: level === 'error' ? new Error().stack : undefined
    };

    this.logBuffer.push(logEntry);

    // Console output para desenvolvimento
    if (process.env.NODE_ENV === 'development') {
      const colors = {
        error: '#ff4444',
        warn: '#ffaa00',
        info: '#4444ff',
        debug: '#888888'
      };
      
      console.log(
        `%c[${level.toUpperCase()}] ${event}`,
        `color: ${colors[level]}; font-weight: bold;`,
        data
      );
    }

    // Flush autom√°tico quando buffer est√° cheio
    if (this.logBuffer.length >= this.config.batchSize) {
      this.flush();
    }
  }

  // M√©tricas de performance em tempo real
  trackMetric(name, value, tags = {}) {
    const metric = {
      name,
      value,
      tags,
      timestamp: Date.now(),
      session: this.userSession.sessionId
    };

    if (!this.metrics.has(name)) {
      this.metrics.set(name, []);
    }

    this.metrics.get(name).push(metric);

    // Manter apenas as √∫ltimas 100 m√©tricas por tipo
    const metrics = this.metrics.get(name);
    if (metrics.length > 100) {
      metrics.shift();
    }

    // Log m√©tricas cr√≠ticas
    if (this.isCriticalMetric(name, value)) {
      this.log('warn', 'critical_metric', metric);
    }
  }

  isCriticalMetric(name, value) {
    const thresholds = {
      'page_load_time': 3000,
      'api_response_time': 2000,
      'memory_usage_mb': 100,
      'error_rate': 0.05
    };

    return thresholds[name] && value > thresholds[name];
  }

  // Rastreamento de intera√ß√µes do usu√°rio
  trackUserInteraction(action, element, data = {}) {
    if (!this.config.enableUserTracking) return;

    const interaction = {
      action,
      element: {
        tagName: element.tagName,
        className: element.className,
        id: element.id,
        textContent: element.textContent?.substring(0, 100)
      },
      data,
      timestamp: Date.now(),
      viewport: {
        x: window.scrollX,
        y: window.scrollY
      }
    };

    this.log('info', 'user_interaction', interaction);
  }

  // Monitoramento de performance autom√°tico
  setupPerformanceMonitoring() {
    if (!this.config.enablePerformanceTracking) return;

    // Core Web Vitals
    this.observeWebVitals();

    // Navigation timing
    window.addEventListener('load', () => {
      setTimeout(() => {
        const navigation = performance.getEntriesByType('navigation')[0];
        this.trackMetric('page_load_time', navigation.loadEventEnd - navigation.fetchStart);
        this.trackMetric('dom_content_loaded', navigation.domContentLoadedEventEnd - navigation.fetchStart);
        this.trackMetric('first_paint', navigation.responseEnd - navigation.fetchStart);
      }, 0);
    });

    // Resource timing
    const observer = new PerformanceObserver((list) => {
      list.getEntries().forEach(entry => {
        if (entry.entryType === 'resource') {
          this.trackMetric('resource_load_time', entry.duration, {
            resource: entry.name,
            type: entry.initiatorType
          });
        }
      });
    });

    observer.observe({ entryTypes: ['resource'] });
  }

  observeWebVitals() {
    // Largest Contentful Paint
    new PerformanceObserver((list) => {
      const entries = list.getEntries();
      const lastEntry = entries[entries.length - 1];
      this.trackMetric('lcp', lastEntry.startTime);
    }).observe({ entryTypes: ['largest-contentful-paint'] });

    // First Input Delay
    new PerformanceObserver((list) => {
      list.getEntries().forEach(entry => {
        this.trackMetric('fid', entry.processingStart - entry.startTime);
      });
    }).observe({ entryTypes: ['first-input'] });

    // Cumulative Layout Shift
    let clsValue = 0;
    new PerformanceObserver((list) => {
      list.getEntries().forEach(entry => {
        if (!entry.hadRecentInput) {
          clsValue += entry.value;
          this.trackMetric('cls', clsValue);
        }
      });
    }).observe({ entryTypes: ['layout-shift'] });
  }

  // Error tracking avan√ßado
  setupErrorTracking() {
    // JavaScript errors
    window.addEventListener('error', (event) => {
      this.log('error', 'javascript_error', {
        message: event.message,
        filename: event.filename,
        lineno: event.lineno,
        colno: event.colno,
        stack: event.error?.stack
      });
    });

    // Unhandled promise rejections
    window.addEventListener('unhandledrejection', (event) => {
      this.log('error', 'unhandled_promise_rejection', {
        reason: event.reason,
        stack: event.reason?.stack
      });
    });

    // Network errors
    const originalFetch = window.fetch;
    window.fetch = async (...args) => {
      const startTime = performance.now();
      try {
        const response = await originalFetch(...args);
        const duration = performance.now() - startTime;
        
        this.trackMetric('api_response_time', duration, {
          url: args[0],
          status: response.status
        });

        if (!response.ok) {
          this.log('warn', 'api_error', {
            url: args[0],
            status: response.status,
            statusText: response.statusText
          });
        }

        return response;
      } catch (error) {
        const duration = performance.now() - startTime;
        this.log('error', 'network_error', {
          url: args[0],
          error: error.message,
          duration
        });
        throw error;
      }
    };
  }

  // Flush logs para servidor
  async flush() {
    if (this.logBuffer.length === 0) return;

    const logs = [...this.logBuffer];
    this.logBuffer = [];

    try {
      await fetch(this.config.endpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          logs,
          session: this.userSession,
          metrics: Object.fromEntries(this.metrics)
        })
      });
    } catch (error) {
      // Re-adicionar logs ao buffer se falhou
      this.logBuffer.unshift(...logs);
      console.error('Failed to send logs:', error);
    }
  }

  // Configurar flush autom√°tico
  setupMonitoring() {
    // Flush peri√≥dico
    setInterval(() => {
      this.flush();
    }, this.config.flushInterval);

    // Flush antes de sair da p√°gina
    window.addEventListener('beforeunload', () => {
      this.flush();
    });

    // Configurar rastreamento de performance
    this.setupPerformanceMonitoring();
    this.setupErrorTracking();

    // Rastreamento de intera√ß√µes
    document.addEventListener('click', (e) => {
      this.trackUserInteraction('click', e.target);
    });

    document.addEventListener('input', (e) => {
      this.trackUserInteraction('input', e.target, {
        value: e.target.type === 'password' ? '[REDACTED]' : e.target.value?.substring(0, 100)
      });
    });
  }

  // Utilit√°rios
  generateSessionId() {
    return 'session_' + Math.random().toString(36).substr(2, 9) + '_' + Date.now();
  }

  getCurrentUserId() {
    // Implementar l√≥gica para obter ID do usu√°rio atual
    return localStorage.getItem('userId') || 'anonymous';
  }

  getConnectionInfo() {
    if ('connection' in navigator) {
      return {
        effectiveType: navigator.connection.effectiveType,
        downlink: navigator.connection.downlink,
        rtt: navigator.connection.rtt
      };
    }
    return null;
  }
}
```

#### üìå Atividade Pr√°tica 3:
üéØ **Objetivo:** Implementar sistema completo de monitoramento no Sistema Lunysse  
üìù **Tarefa:**
- Implementar MonitoringSystem class com logging estruturado
- Configurar rastreamento autom√°tico de Core Web Vitals
- Desenvolver sistema de error tracking com categoriza√ß√£o
- Implementar monitoramento de intera√ß√µes do usu√°rio
- Criar dashboard de m√©tricas em tempo real
- Desenvolver alertas para m√©tricas cr√≠ticas
- Implementar sistema de flush inteligente para logs
- Criar relat√≥rios de performance automatizados
- Integrar com servi√ßos de monitoramento externos
- Testar sistema com cen√°rios de alta carga

---

### T√≥pico 4: Bundle Optimization e Code Splitting (60 min)

#### üìå Demonstra√ß√£o Pr√°tica:
Otimiza√ß√£o avan√ßada de build e carregamento:
- **Bundle Analysis:** An√°lise detalhada do tamanho do bundle
- **Code Splitting:** Divis√£o inteligente de c√≥digo
- **Tree Shaking:** Elimina√ß√£o de c√≥digo n√£o utilizado
- **Lazy Loading:** Carregamento sob demanda de componentes
- **Preloading Strategies:** Estrat√©gias de pr√©-carregamento

#### üìå Atividade Pr√°tica 4:
üéØ **Objetivo:** Otimizar bundle e implementar code splitting no Sistema Lunysse  
üìù **Tarefa:**
- Analisar bundle atual com webpack-bundle-analyzer
- Implementar code splitting por rotas e funcionalidades
- Configurar lazy loading para componentes pesados
- Otimizar imports e eliminar c√≥digo n√£o utilizado
- Implementar preloading inteligente de recursos
- Configurar compression e minification avan√ßada
- Criar estrat√©gias de cache para assets
- Medir impacto das otimiza√ß√µes na performance
- Implementar loading states para componentes lazy
- Documentar estrat√©gias de otimiza√ß√£o implementadas

---

### Encerramento e Reflex√£o (45 min)

#### üìå Discuss√£o em grupo:
**Tema:** "Como debugging e monitoramento sistem√°ticos garantem a confiabilidade de sistemas m√©dicos cr√≠ticos?"

Reflex√£o aprofundada sobre:
- **Import√¢ncia do monitoramento:** Como detectar problemas antes que afetem usu√°rios
- **Cultura de qualidade:** Estabelecer processos de qualidade na equipe
- **Debugging proativo:** Identificar problemas potenciais antes que se manifestem
- **Performance como requisito:** Tratar performance como requisito funcional
- **Monitoramento em produ√ß√£o:** Import√¢ncia de observabilidade em sistemas cr√≠ticos

#### üìå Desafio para a pr√≥xima aula:
Criar um sistema completo de qualidade para o Sistema Lunysse:
- Dashboard de monitoramento em tempo real
- Alertas autom√°ticos para problemas cr√≠ticos
- Relat√≥rios de qualidade automatizados
- Processo de debugging documentado
- M√©tricas de qualidade estabelecidas

---

## üìå Objetos de Aprendizagem

üìù **Advanced Debugging Toolkit:** Conjunto completo de ferramentas de debugging  
üìù **Memory Profiling Guide:** Manual de an√°lise e otimiza√ß√£o de mem√≥ria  
üìù **Monitoring System:** Sistema completo de monitoramento e logging  
üìù **Performance Optimization Guide:** Guia de otimiza√ß√£o de performance  
üìù **Quality Assurance Process:** Processo documentado de garantia de qualidade  
üìù **Error Handling Framework:** Framework robusto de tratamento de erros  
üìù **Bundle Optimization Toolkit:** Ferramentas de otimiza√ß√£o de build

---

## üéØ Avalia√ß√£o

### Crit√©rios de Avalia√ß√£o:

‚úÖ **Debugging Skills (25%):** Profici√™ncia no uso de ferramentas de debugging  
‚úÖ **Performance Optimization (25%):** Qualidade das otimiza√ß√µes implementadas  
‚úÖ **Monitoring Implementation (25%):** Completude do sistema de monitoramento  
‚úÖ **Code Quality (25%):** Qualidade geral do c√≥digo e processos implementados

### Instrumentos de Avalia√ß√£o:

- **Practical debugging session:** Resolu√ß√£o de problemas reais em tempo real
- **Performance metrics:** Medi√ß√£o de melhorias obtidas
- **Code review:** An√°lise da qualidade do c√≥digo de monitoramento
- **System reliability test:** Teste de confiabilidade sob carga

---

## üéì Conclus√£o

Ao final desta aula, os alunos ser√£o capazes de:

- **Dominar ferramentas avan√ßadas** de debugging e profiling
- **Implementar sistemas robustos** de monitoramento e logging
- **Otimizar performance** usando t√©cnicas profissionais
- **Detectar e corrigir** vazamentos de mem√≥ria e problemas de performance
- **Estabelecer processos** de qualidade e confiabilidade
- **Criar dashboards** de monitoramento em tempo real

Esta compet√™ncia √© fundamental para desenvolvedores que trabalham com sistemas cr√≠ticos, estabelecendo um padr√£o profissional de qualidade que garante confiabilidade e performance em aplica√ß√µes de produ√ß√£o.

---

**Indicador de Compet√™ncia Trabalhado:**  
‚úîÔ∏è **Indicador 5** - Analisa desempenho e inconsist√™ncias no funcionamento do website, de acordo com os padr√µes W3C

**Metodologia Ativa Aplicada:**  
- **Problem-Solving Learning:** Resolu√ß√£o de problemas reais de performance e qualidade
- **Data-Driven Development:** Desenvolvimento baseado em m√©tricas e dados  
- **Continuous Improvement:** Melhoria cont√≠nua baseada em monitoramento  
- **Collaborative Debugging:** Debugging colaborativo e compartilhamento de conhecimento